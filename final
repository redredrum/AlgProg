// iter.cpp : Этот файл содержит функцию "main". Здесь начинается и заканчивается выполнение программы.
//

#include "pch.h"
#include <iostream>
#include <vector>
#include <algorithm>
#include <iterator>
#include <cassert>
#include <queue>

using namespace std;

template <typename T>
class fixed_array
{
public:

	typedef int size_type;

	class iterator
	{
	public:
		typedef iterator self_type;
		typedef T value_type;
		typedef T& reference;
		typedef T* pointer;
		typedef std::forward_iterator_tag iterator_category;
		typedef int difference_type;
		iterator(pointer ptr) : ptr_(ptr) { }
		self_type operator++() { self_type i = *this; ptr_++; return i; }
		self_type operator--() { self_type i = *this; ptr_--; return i; }
		self_type operator++(int junk) { ptr_++; return *this; }
		self_type operator--(int junk) { ptr_--; return *this; }
		reference operator*() { return *ptr_; }
		pointer operator->() { return ptr_; }
		bool operator==(const self_type& rhs) { return ptr_ == rhs.ptr_; }
		bool operator!=(const self_type& rhs) { return ptr_ != rhs.ptr_; }
	private:
		pointer ptr_;
	};

	class const_iterator
	{
	public:
		typedef const_iterator self_type;
		typedef T value_type;
		typedef T& reference;
		typedef T* pointer;
		typedef int difference_type;
		typedef std::forward_iterator_tag iterator_category;
		const_iterator(pointer ptr) : ptr_(ptr) { }
		self_type operator++() { self_type i = *this; ptr_++; return i; }
		self_type operator--() { self_type i = *this; ptr_--; return i; }
		self_type operator++(int junk) { ptr_++; return *this; }
		self_type operator--(int junk) { ptr_--; return *this; }
		const reference operator*() { return *ptr_; }
		const pointer operator->() { return ptr_; }
		bool operator==(const self_type& rhs) { return ptr_ == rhs.ptr_; }
		bool operator!=(const self_type& rhs) { return ptr_ != rhs.ptr_; }
	private:
		pointer ptr_;
	};


	fixed_array(size_type size) : size_(size * size) {
		data_ = new T[size_];
	}

	size_type size() const { return size_; }

	T& operator[](size_type index)
	{
		assert(index < size_);
		return data_[index];
	}

	const T& operator[](size_type index) const
	{
		assert(index < size_);
		return data_[index];
	}

	iterator begin()
	{
		return iterator(data_);
	}

	iterator end()
	{
		return iterator(data_ + size_);
	}

	const_iterator begin() const
	{
		return const_iterator(data_);
	}

	const_iterator end() const
	{
		return const_iterator(data_ + size_);
	}

private:
	T* data_;
	size_type size_;
};

template <class T>
void bfs(fixed_array<T> arr, int size__) {
	queue<T> Queue;
	//int counter = 0;
	T *nodes = new T[size__]; // вершины графа
	for (int i = 0; i < size__; i++)
		nodes[i] = 0; // исходно все вершины равны 0
	Queue.push(0); // помещаем в очередь первую вершину
	while (!Queue.empty()) {
		int node = Queue.front();
		Queue.pop(); //берем вершину из очереди
		nodes[node] = 2; // отмечаем ее как посещенную
		auto it_starter = arr.begin();
		int counter = 0;
		while (counter != node * size__) { //переход к нужной вершине
			counter++;
			it_starter++;
		}
		counter = 0;
		auto it_finisher = it_starter; //все ок!
		while (counter != size__ - 1) { //переход к концу вершине
			counter++;
			it_finisher++;
		}
		counter = 0;
		int j = 0;
		it_finisher++;
		for (auto it_ = it_starter; it_ != it_finisher; it_++) {
			if (*it_ == 1 && nodes[j] == 0) {
			//	cout << "|" << *it_ << "|" << endl;
				Queue.push(j);
				nodes[j] = 1;
			}
			j++;
		}
		cout << node + 1 << endl;
	}
}

int main()
{
	fixed_array<double> point3d(2);
	for (int i = 0; i < 2* 2; i++) cin >> point3d[i];
	bfs(point3d, 2);
	//std::cout << std::endl;

	
	return 0;
}
